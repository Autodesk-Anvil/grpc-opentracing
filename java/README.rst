#####################
GRPC-Java OpenTracing
#####################

============
Installation
============

This package is available on Maven Central and can be added to your project as follows:

**Maven**

.. code-block::

    <dependencies>
        <dependency>
            <groupId>io.opentracing.contrib.grpc</groupId>
            <artifactId>grpc-opentracing</artifactId>
            <version>0.1.0</version>
        </dependency>
    </dependencies>

**Gradle**

.. code-block::
    
    compile 'io.opentracing.contrib.grpc:grpc-opentracing:0.1.0'

==========
Quickstart
========== 

If you want to add basic tracing to your clients and servers, you can do so in a few short and simple steps, as shown below. (These code snippets use the grpc example's ``GreeterGrpc``, generated by protocol buffers.)

**Servers**

- Instantiate a tracer
- Create a ``ServerTracingInterceptor``
- Intercept a service 
- (Optional) Access the `current span`_

.. _current span: `Current Span Context`_
    
.. code-block:: java

    import io.opentracing.Tracer;

    public class YourServer {

        private int port;
        private Server server;

        private void start() throws IOException {
        
            Tracer tracer = aTracerImpl;
            ServerTracingInterceptor tracingInterceptor = new ServerTracingInterceptor(tracer);

            server = ServerBuilder.forPort(port)
                .addService(tracingInterceptor.intercept(someServiceDef))
                .build()
                .start();
        }
    }

**Clients**

- Instantiate a tracer
- Create a ``ClientTracingInterceptor``
- Intercept the client channel

.. code-block:: java

    import io.opentracing.Tracer;

    public class YourClient {

        private final ManagedChannel channel;
        private final GreeterGrpc.GreeterBlockingStub blockingStub;

        public YourClient(String host, int port) {

            channel = ManagedChannelBuilder.forAddress(host, port)
                .usePlaintext(true)
                .build();
        
            Tracer tracer = aTracerImpl;
            ClientTracingInterceptor tracingInterceptor = new ClientTracingInterceptor(tracer)

            blockingStub = GreeterGrpc.newBlockingStub(tracingInterceptor.intercept(channel));
        }
    }

==============
Server Tracing
==============

A ``ServerTracingInterceptor`` uses default settings, which you can override by creating it using a ``ServerTracingInterceptor.Builder``.

- ``withOperationName(OperationNameConstructor constructor)``: Define how the operation name is constructed for all spans created for the intercepted service. Default sets the operation name as the name of the RPC method. More details `below`_.
- ``withStreaming()``: Logs to the server span whenever a message is received.
- ``withVerbosity()``: Logs to the server span additional events, such as message received, half close (client finished sending messages), and call complete. Default only logs if a call is cancelled.  
- ``withTracedAttributes(ServerRequestAttribute... attrs)``: Sets tags on the server span in case you want to track information about the RPC call. See ServerRequestAttribute.java for a list of traceable request attributes.

**Example**:

.. code-block:: java

    ServerTracingInterceptor tracingInterceptor = new ServerTracingInterceptor
        .Builder(tracer)
        .withStreaming()
        .withVerbosity()
        .withOperationName(new OperationNameConstructor() {
            @Override
            public <ReqT, RespT> String constructOperationName(MethodDescriptor<ReqT, RespT> method) {
                // construct some operation name from the method descriptor
            }
        })
        .withTracedAttributes(ServerRequestAttribute.HEADERS, 
            ServerRequestAttribute.METHOD_TYPE)
        .build();

==============
Client Tracing
==============

A ``ClientTracingInterceptor`` also has default settings, which you can override by creating it using a ``ServerTracingInterceptor.Builder``.

- ``withOperationName(String operationName)``: Define how the operation name is constructed for all spans created for this intercepted client. Default is the name of the RPC method. More details `below`_.
- ``withStreaming()``: Logs to the client span whenever a message is sent or a response is received.
- ``withVerbosity()``: Logs to the client span additional events, such as call started, message sent, half close (client finished sending messages), response received, and call complete. Default only logs if a call is cancelled.  
- ``withTracedAttributes(ClientRequestAttribute... attrs)``: Sets tags on the client span in case you want to track information about the RPC call. See ClientRequestAttribute.java for a list of traceable request attributes.

**Example**:

.. code-block:: java

    ClientTracingInterceptor tracingInterceptor = new ClientTracingInterceptor
        .Builder(tracer)
        .withStreaming()
        .withVerbosity()
        .withOperationName(new OperationNameConstructor() {
            @Override
            public <ReqT, RespT> String constructOperationName(MethodDescriptor<ReqT, RespT> method) {
                // construct some operation name from the method descriptor
            }
        })
        .withTracingAttributes(ClientRequestAttribute.ALL_CALL_OPTIONS,
            ClientRequestAttribute.HEADERS)
        .build();

.. _below: `Operation Names`_

====================
Current Span Context
====================

In your server request handler, you can access the current active span for that request by calling

.. code-block:: java

    Span span = OpenTracingContextKey.activeSpan();

This is useful if you want to manually set tags on the span, log important events, or create a new child span for internal units of work. You can also use this key to wrap these internal units of work with a new context that has a user-defined active span.

For example:

.. code-block:: java

    Tracer tracer = aTracerImpl;

    // some unit of internal work that you want to trace
    Runnable internalWork = someInternalWork

    // a wrapper that traces the work of the runnable
    class TracedRunnable implements Runnable {
        Runnable work;
        Tracer tracer;
        
        TracedRunnable(Runnable work, Tracer tracer) {
            this.work = work;
            this.tracer = tracer;
        }

        public void run() {

            // create a child span for the current active span
            Span span = tracer
                .buildSpan("internal-work")
                .asChildOf(OpenTracingContextKey.activeSpan())
                .start();

            // create a new context with the child span as the active span
            Context contextWithNewSpan = Context.current()
                .withValue(OpenTracingContextKey.get(), span);

            // wrap the original work and run it
            Runnable tracedWork = contextWithNewSpan.wrap(this.work);
            tracedWork.run();

            // make sure to finish any manually created spans!
            span.finish();
        }
    }

    Runnable tracedInternalWork = new TracedRunnable(internalWork, tracer);
    tracedInternalWork.run();

Continuing a Trace
------------------

Sometimes you may have a client that is created within the scope of a service. If this service is traced, and there is an active span present in ``Context.current()``, then the ClientTracingInterceptor will recognize the active span and continue the current trace automatically.

===============
Operation Names
===============

The default operation name for any span is the RPC method name (``io.grpc.MethodDescriptor.getFullMethodName()``). However, you may want to add your own prefixes, alter the name, or define a new name. For examples of good operation names, check out the OpenTracing `semantics`_.

To alter the operation name, you need to add an implementation of the interface ``OperationNameConstructor`` to the ``ClientTracingInterceptor.Builder`` or ``ServerTracingInterceptor.Builder``. For example, if you want to add a prefix to the default operation name of your ClientInterceptor, your code would look like this:

.. code-block::

    ClientTracingInterceptor interceptor = ClientTracingInterceptor.Builder ...
        .withOperationName(new OperationNameConstructor() {
            @Override
            public <ReqT, RespT> String constructOperationName(MethodDescriptor<ReqT, RespT> method) {
                return "your-prefix" + method.getFullMethodName();
            }
        })
        .with....
        .build()

.. _semantics: http://opentracing.io/spec/#operation-names

===================================
Integrating with Other Interceptors
===================================

Although we provide ``ServerTracingInterceptor.intercept(service)`` and ``ClientTracingInterceptor.intercept(channel)`` methods, you don't want to use these if you're chaining multiple interceptors. Instead, use the following code (preferably putting the tracing interceptor at the top of the interceptor stack so that it traces the entire request lifecycle, including other interceptors):

**Servers**

.. code-block:: java

    server = ServerBuilder.forPort(port)
        .addService(ServerInterceptors.intercept(service, someInterceptor, 
            someOtherInterceptor, serverTracingInterceptor))
        .build()
        .start();

**Clients**

.. code-block:: java

    blockingStub = GreeterGrpc.newBlockingStub(ClientInterceptors.intercept(channel,
        someInterceptor, someOtherInterceptor, clientTracingInterceptor));
